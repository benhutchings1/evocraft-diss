import numpy as np
import neat
from typing import List

def generate(genome_id:int, net:neat.nn.FeedForwardNetwork, input_config:List[float]) -> tuple:
    """
    Uses a given model to create a house to the specified height, length, width
    Get the model to predict a block by giving the surrounding blocks
    
    returns a height x length x width sized 3d array of values generated by net 
    """
    template_input = np.zeros((20 + len(input_config)))
    l_config = len(input_config)
    template_input[:l_config] = input_config
    height = input_config[0]
    length = input_config[1]
    width = input_config[2]

    out = np.zeros((height, length, width)).astype(int)
    out.fill(-1)
    for h in range(height):
        for l in range(length):
            for w in range(width):
                surr_points = __get_surrounding_points(out, w, h, l)
                # Give current coords of block placed
                template_input[l_config] = h
                template_input[l_config + 1] = l
                template_input[l_config + 2] = w
                # Give surrounding blocks
                template_input[l_config + 3:] = surr_points

                # Use model to predict current point
                out[h][l][w] = np.argmax(net.activate(template_input))

    return genome_id, out


def __get_surrounding_points(ar:np.array, x:int, y:int, z:int) -> np.array:
    """
    Given a point (x, y, z) get all points x±1 y±1 z±1
    returns a 1d array with values
    """
    out = np.zeros((2 * 3 * 3) - 1).astype(int)
    out.fill(-1)
    idx = 0
    for yi in range(0, -2, -1):
        # Check if y row exists
        if not y + yi < 0:
            for zi in range(-1, 2):
                # Check if z is within bounds of array
                if zi + z >= 0 and zi + z < ar.shape[1]:
                    for xi in range(-1, 2):
                        # Check if x is within boundries
                        if xi + x >= 0 and xi + x < ar.shape[2]:
                            if xi == 0 and zi == 0 and yi == 0:
                                pass
                            else:
                                out[idx] = ar[y+yi][z+zi][x+xi]
                                idx += 1                            
                        else:
                            # If outside boundries skip x
                            idx += 1
                else:
                    # If outside boundries skip row
                    idx += 3   
        # If y outside boundries then break
        # Only going down 1 in y axis so ignore if nonexistant
                
    return out
