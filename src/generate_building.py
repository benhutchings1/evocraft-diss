import numpy as np
import neat
from typing import List
from concurrent.futures import ProcessPoolExecutor, as_completed

def parallel_generate(nets:neat.nn.FeedForwardNetwork, input_config:List[float]) -> tuple:
    # Get genome information
    net_results = [None] * (len(nets) + 1)
    
    # Generate one building using each genome
    # Split processing over all CPU's
    with ProcessPoolExecutor() as exe:
        # Send function call to be parallalised
        # Give index to map back to
        futures = [
            exe.submit(generate, i, net, input_config)
                        for i, net in enumerate(nets)
                ]
        # Process results once completed
        for result in as_completed(futures):
            # Get result from future when completed
            result = result.result()
            # Map results back to array
            net_results[result[0]] = result[1]
    return net_results

def generate(genome_id:int, net:neat.nn.FeedForwardNetwork, input_config:List[float]):
    """
    Uses a given model to create a house to the specified height, length, width
    Get the model to predict a block by giving the surrounding blocks
    
    returns a height x length x width sized 3d array of values generated by net 
    """
    template_input = np.zeros((20 + len(input_config)))
    l_config = len(input_config)
    template_input[:l_config] = input_config
    height = input_config[0]
    length = input_config[1]
    width = input_config[2]

    out = np.zeros((height, length, width)).astype(int)
    out.fill(-1)
    for h in range(height):
        for l in range(length):
            for w in range(width):
                surr_points = __get_surrounding_points(out, w, h, l)
                # Give current coords of block placed
                template_input[l_config] = h
                template_input[l_config + 1] = l
                template_input[l_config + 2] = w
                # Give surrounding blocks
                template_input[l_config + 3:] = surr_points

                # Use model to predict current point
                out[h][l][w] = np.argmax(net.activate(template_input))

    return genome_id, out


def __get_surrounding_points(ar:np.array, x:int, y:int, z:int) -> np.array:
    """
    Given a point (x, y, z) get all points x±1 y±1 z±1
    returns a 1d array with values
    """
    out = np.zeros((2 * 3 * 3) - 1).astype(int)
    out.fill(-1)
    idx = 0
    for yi in range(0, -2, -1):
        # Check if y row exists
        if not y + yi < 0:
            for zi in range(-1, 2):
                # Check if z is within bounds of array
                if zi + z >= 0 and zi + z < ar.shape[1]:
                    for xi in range(-1, 2):
                        # Check if x is within boundries
                        if xi + x >= 0 and xi + x < ar.shape[2]:
                            if xi == 0 and zi == 0 and yi == 0:
                                pass
                            else:
                                out[idx] = ar[y+yi][z+zi][x+xi]
                                idx += 1                            
                        else:
                            # If outside boundries skip x
                            idx += 1
                else:
                    # If outside boundries skip row
                    idx += 3   
        # If y outside boundries then break
        # Only going down 1 in y axis so ignore if nonexistant
                
    return out
